/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef serialize_TYPES_H
#define serialize_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace thrift_serialize {

struct ENUMERATION {
  enum type {
    ONE = 0,
    TWO = 1,
    THREE = 2,
    FOUR = 3
  };
};

extern const std::map<int, const char*> _ENUMERATION_VALUES_TO_NAMES;

typedef struct _ints__isset {
  _ints__isset() : id(false), int1(false), int2(false), int3(false), int4(false) {}
  bool id;
  bool int1;
  bool int2;
  bool int3;
  bool int4;
} _ints__isset;

class ints {
 public:

  static const char* ascii_fingerprint; // = "3C83C6E0747D926A59C65E8FC8C39084";
  static const uint8_t binary_fingerprint[16]; // = {0x3C,0x83,0xC6,0xE0,0x74,0x7D,0x92,0x6A,0x59,0xC6,0x5E,0x8F,0xC8,0xC3,0x90,0x84};

  ints() : id(0), int1(0), int2(0), int3(0), int4(0) {
  }

  virtual ~ints() throw() {}

  int64_t id;
  int64_t int1;
  int64_t int2;
  int32_t int3;
  int32_t int4;

  _ints__isset __isset;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_int1(const int64_t val) {
    int1 = val;
  }

  void __set_int2(const int64_t val) {
    int2 = val;
  }

  void __set_int3(const int32_t val) {
    int3 = val;
  }

  void __set_int4(const int32_t val) {
    int4 = val;
  }

  bool operator == (const ints & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(int1 == rhs.int1))
      return false;
    if (!(int2 == rhs.int2))
      return false;
    if (!(int3 == rhs.int3))
      return false;
    if (!(int4 == rhs.int4))
      return false;
    return true;
  }
  bool operator != (const ints &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ints & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ints &a, ints &b);

typedef struct _mixed__isset {
  _mixed__isset() : id(false), int1(false), int2(false), int3(false), float1(false), text1(false), enum1(false) {}
  bool id;
  bool int1;
  bool int2;
  bool int3;
  bool float1;
  bool text1;
  bool enum1;
} _mixed__isset;

class mixed {
 public:

  static const char* ascii_fingerprint; // = "93BB92AB0EC9C814FB55637E50B5208C";
  static const uint8_t binary_fingerprint[16]; // = {0x93,0xBB,0x92,0xAB,0x0E,0xC9,0xC8,0x14,0xFB,0x55,0x63,0x7E,0x50,0xB5,0x20,0x8C};

  mixed() : id(0), int1(0), int2(0), int3(0), float1(0), text1(), enum1((ENUMERATION::type)0) {
  }

  virtual ~mixed() throw() {}

  int32_t id;
  int32_t int1;
  int64_t int2;
  int64_t int3;
  double float1;
  std::string text1;
  ENUMERATION::type enum1;

  _mixed__isset __isset;

  void __set_id(const int32_t val) {
    id = val;
  }

  void __set_int1(const int32_t val) {
    int1 = val;
  }

  void __set_int2(const int64_t val) {
    int2 = val;
  }

  void __set_int3(const int64_t val) {
    int3 = val;
  }

  void __set_float1(const double val) {
    float1 = val;
  }

  void __set_text1(const std::string& val) {
    text1 = val;
  }

  void __set_enum1(const ENUMERATION::type val) {
    enum1 = val;
  }

  bool operator == (const mixed & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(int1 == rhs.int1))
      return false;
    if (!(int2 == rhs.int2))
      return false;
    if (!(int3 == rhs.int3))
      return false;
    if (!(float1 == rhs.float1))
      return false;
    if (!(text1 == rhs.text1))
      return false;
    if (!(enum1 == rhs.enum1))
      return false;
    return true;
  }
  bool operator != (const mixed &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mixed & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(mixed &a, mixed &b);

typedef struct _container_vec__isset {
  _container_vec__isset() : id(false), int1(false), text1(false), stringvec(false), intvec(false) {}
  bool id;
  bool int1;
  bool text1;
  bool stringvec;
  bool intvec;
} _container_vec__isset;

class container_vec {
 public:

  static const char* ascii_fingerprint; // = "DD16BA0BB5133F139B056F1DCD6F058A";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0x16,0xBA,0x0B,0xB5,0x13,0x3F,0x13,0x9B,0x05,0x6F,0x1D,0xCD,0x6F,0x05,0x8A};

  container_vec() : id(0), int1(0), text1() {
  }

  virtual ~container_vec() throw() {}

  int32_t id;
  int64_t int1;
  std::string text1;
  std::vector<std::string>  stringvec;
  std::vector<int64_t>  intvec;

  _container_vec__isset __isset;

  void __set_id(const int32_t val) {
    id = val;
  }

  void __set_int1(const int64_t val) {
    int1 = val;
  }

  void __set_text1(const std::string& val) {
    text1 = val;
  }

  void __set_stringvec(const std::vector<std::string> & val) {
    stringvec = val;
  }

  void __set_intvec(const std::vector<int64_t> & val) {
    intvec = val;
  }

  bool operator == (const container_vec & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(int1 == rhs.int1))
      return false;
    if (!(text1 == rhs.text1))
      return false;
    if (!(stringvec == rhs.stringvec))
      return false;
    if (!(intvec == rhs.intvec))
      return false;
    return true;
  }
  bool operator != (const container_vec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const container_vec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(container_vec &a, container_vec &b);

typedef struct _container_map__isset {
  _container_map__isset() : id(false), int1(false), text1(false), map1(false) {}
  bool id;
  bool int1;
  bool text1;
  bool map1;
} _container_map__isset;

class container_map {
 public:

  static const char* ascii_fingerprint; // = "1C8C5BD8F089C0949B57A595A630C52B";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0x8C,0x5B,0xD8,0xF0,0x89,0xC0,0x94,0x9B,0x57,0xA5,0x95,0xA6,0x30,0xC5,0x2B};

  container_map() : id(0), int1(0), text1() {
  }

  virtual ~container_map() throw() {}

  int32_t id;
  int64_t int1;
  std::string text1;
  std::map<int32_t, std::string>  map1;

  _container_map__isset __isset;

  void __set_id(const int32_t val) {
    id = val;
  }

  void __set_int1(const int64_t val) {
    int1 = val;
  }

  void __set_text1(const std::string& val) {
    text1 = val;
  }

  void __set_map1(const std::map<int32_t, std::string> & val) {
    map1 = val;
  }

  bool operator == (const container_map & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(int1 == rhs.int1))
      return false;
    if (!(text1 == rhs.text1))
      return false;
    if (!(map1 == rhs.map1))
      return false;
    return true;
  }
  bool operator != (const container_map &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const container_map & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(container_map &a, container_map &b);

typedef struct _complex__isset {
  _complex__isset() : id(false), text1(false), text2(false), text3(false), int1(false), int2(false), int3(false), text4(false), enum1(false), float1(false), int4(false), uint1(false), uint2(false), int5(false), int6(false), float2(false), text5(false) {}
  bool id;
  bool text1;
  bool text2;
  bool text3;
  bool int1;
  bool int2;
  bool int3;
  bool text4;
  bool enum1;
  bool float1;
  bool int4;
  bool uint1;
  bool uint2;
  bool int5;
  bool int6;
  bool float2;
  bool text5;
} _complex__isset;

class complex {
 public:

  static const char* ascii_fingerprint; // = "8610B2CE5872B1B4FDE38A16FA17BF4D";
  static const uint8_t binary_fingerprint[16]; // = {0x86,0x10,0xB2,0xCE,0x58,0x72,0xB1,0xB4,0xFD,0xE3,0x8A,0x16,0xFA,0x17,0xBF,0x4D};

  complex() : id(0), text1(), text2(), text3(), int1(0), int2(0), int3(0), text4(), enum1((ENUMERATION::type)0), float1(0), int4(0), uint1(0), uint2(0), int5(0), int6(0), float2(0), text5() {
  }

  virtual ~complex() throw() {}

  int64_t id;
  std::string text1;
  std::string text2;
  std::string text3;
  int32_t int1;
  int32_t int2;
  int32_t int3;
  std::string text4;
  ENUMERATION::type enum1;
  double float1;
  int64_t int4;
  int32_t uint1;
  int64_t uint2;
  int64_t int5;
  int32_t int6;
  double float2;
  std::string text5;

  _complex__isset __isset;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_text1(const std::string& val) {
    text1 = val;
  }

  void __set_text2(const std::string& val) {
    text2 = val;
  }

  void __set_text3(const std::string& val) {
    text3 = val;
  }

  void __set_int1(const int32_t val) {
    int1 = val;
  }

  void __set_int2(const int32_t val) {
    int2 = val;
  }

  void __set_int3(const int32_t val) {
    int3 = val;
  }

  void __set_text4(const std::string& val) {
    text4 = val;
  }

  void __set_enum1(const ENUMERATION::type val) {
    enum1 = val;
  }

  void __set_float1(const double val) {
    float1 = val;
  }

  void __set_int4(const int64_t val) {
    int4 = val;
  }

  void __set_uint1(const int32_t val) {
    uint1 = val;
  }

  void __set_uint2(const int64_t val) {
    uint2 = val;
  }

  void __set_int5(const int64_t val) {
    int5 = val;
  }

  void __set_int6(const int32_t val) {
    int6 = val;
  }

  void __set_float2(const double val) {
    float2 = val;
  }

  void __set_text5(const std::string& val) {
    text5 = val;
  }

  bool operator == (const complex & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(text1 == rhs.text1))
      return false;
    if (!(text2 == rhs.text2))
      return false;
    if (!(text3 == rhs.text3))
      return false;
    if (!(int1 == rhs.int1))
      return false;
    if (!(int2 == rhs.int2))
      return false;
    if (!(int3 == rhs.int3))
      return false;
    if (!(text4 == rhs.text4))
      return false;
    if (!(enum1 == rhs.enum1))
      return false;
    if (!(float1 == rhs.float1))
      return false;
    if (!(int4 == rhs.int4))
      return false;
    if (!(uint1 == rhs.uint1))
      return false;
    if (!(uint2 == rhs.uint2))
      return false;
    if (!(int5 == rhs.int5))
      return false;
    if (!(int6 == rhs.int6))
      return false;
    if (!(float2 == rhs.float2))
      return false;
    if (!(text5 == rhs.text5))
      return false;
    return true;
  }
  bool operator != (const complex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const complex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(complex &a, complex &b);

typedef struct _Message__isset {
  _Message__isset() : int_msg(false), mixed_msg(false), container_vec_msg(false), container_map_msg(false), complex_msg(false) {}
  bool int_msg;
  bool mixed_msg;
  bool container_vec_msg;
  bool container_map_msg;
  bool complex_msg;
} _Message__isset;

class Message {
 public:

  static const char* ascii_fingerprint; // = "303024DB9EB3741B1EEC81F8AC9C6DC9";
  static const uint8_t binary_fingerprint[16]; // = {0x30,0x30,0x24,0xDB,0x9E,0xB3,0x74,0x1B,0x1E,0xEC,0x81,0xF8,0xAC,0x9C,0x6D,0xC9};

  Message() {
  }

  virtual ~Message() throw() {}

  ints int_msg;
  mixed mixed_msg;
  container_vec container_vec_msg;
  container_map container_map_msg;
  complex complex_msg;

  _Message__isset __isset;

  void __set_int_msg(const ints& val) {
    int_msg = val;
  }

  void __set_mixed_msg(const mixed& val) {
    mixed_msg = val;
  }

  void __set_container_vec_msg(const container_vec& val) {
    container_vec_msg = val;
  }

  void __set_container_map_msg(const container_map& val) {
    container_map_msg = val;
  }

  void __set_complex_msg(const complex& val) {
    complex_msg = val;
  }

  bool operator == (const Message & rhs) const
  {
    if (!(int_msg == rhs.int_msg))
      return false;
    if (!(mixed_msg == rhs.mixed_msg))
      return false;
    if (!(container_vec_msg == rhs.container_vec_msg))
      return false;
    if (!(container_map_msg == rhs.container_map_msg))
      return false;
    if (!(complex_msg == rhs.complex_msg))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Message &a, Message &b);

} // namespace

#endif
