// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: serialize.capnp

#ifndef CAPNP_INCLUDED_c95f38542f78fdf9_
#define CAPNP_INCLUDED_c95f38542f78fdf9_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 5003
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(bd12a8840057ab5f);
enum class ENUMERATION_bd12a8840057ab5f: uint16_t {
  ONE,
  TWO,
  THREE,
  FOUR,
};
CAPNP_DECLARE_ENUM(ENUMERATION, bd12a8840057ab5f);
CAPNP_DECLARE_SCHEMA(9dd607458fe93956);
CAPNP_DECLARE_SCHEMA(8cc7cd8f92a2ad2d);
CAPNP_DECLARE_SCHEMA(ebdb8584e075c955);
CAPNP_DECLARE_SCHEMA(d5f923118f304a35);
CAPNP_DECLARE_SCHEMA(b50fc5dc2adfa892);
CAPNP_DECLARE_SCHEMA(c967c9b682e98ab4);
CAPNP_DECLARE_SCHEMA(f1acf663667b09ab);
CAPNP_DECLARE_SCHEMA(860ba9e9f415fbc6);
CAPNP_DECLARE_SCHEMA(e9b3b4941fbbbae2);
CAPNP_DECLARE_SCHEMA(e3c9b5a7ecd16e15);
CAPNP_DECLARE_SCHEMA(b235479c76ffdf42);
CAPNP_DECLARE_SCHEMA(bea762291acf7e0e);
CAPNP_DECLARE_SCHEMA(9dafef1309ac2eaf);
CAPNP_DECLARE_SCHEMA(82fd20ab7646e5cd);

}  // namespace schemas
}  // namespace capnp

namespace capnp_bench {

typedef ::capnp::schemas::ENUMERATION_bd12a8840057ab5f ENUMERATION;

struct Ints {
  Ints() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9dd607458fe93956, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IntList {
  IntList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8cc7cd8f92a2ad2d, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Mixed {
  Mixed() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ebdb8584e075c955, 4, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct MixedList {
  MixedList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5f923118f304a35, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct ContainerVec {
  ContainerVec() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b50fc5dc2adfa892, 2, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct ContainerVecList {
  ContainerVecList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c967c9b682e98ab4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

template <typename Key = ::capnp::AnyPointer, typename Value = ::capnp::AnyPointer>
struct Map {
  Map() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Entry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1acf663667b09ab, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand = ::capnp::_::ChooseBrand<_capnpPrivate, Key, Value>::brand;
    #endif  // !CAPNP_LITE
  };
};

template <typename Key, typename Value>
struct Map<Key, Value>::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(860ba9e9f415fbc6, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand = ::capnp::_::ChooseBrand<_capnpPrivate, Key, Value>::brand;
    #endif  // !CAPNP_LITE
  };
};

struct IntKey {
  IntKey() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e9b3b4941fbbbae2, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct StringMap {
  StringMap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3c9b5a7ecd16e15, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct ContainerMap {
  ContainerMap() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b235479c76ffdf42, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct ContainerMapList {
  ContainerMapList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bea762291acf7e0e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct Complex {
  Complex() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9dafef1309ac2eaf, 9, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct ComplexList {
  ComplexList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(82fd20ab7646e5cd, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Ints::Reader {
public:
  typedef Ints Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getId() const;

  inline  ::int64_t getInt1() const;

  inline  ::int64_t getInt2() const;

  inline  ::int32_t getInt3() const;

  inline  ::int32_t getInt4() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Ints::Builder {
public:
  typedef Ints Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getId();
  inline void setId( ::int64_t value);

  inline  ::int64_t getInt1();
  inline void setInt1( ::int64_t value);

  inline  ::int64_t getInt2();
  inline void setInt2( ::int64_t value);

  inline  ::int32_t getInt3();
  inline void setInt3( ::int32_t value);

  inline  ::int32_t getInt4();
  inline void setInt4( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Ints::Pipeline {
public:
  typedef Ints Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IntList::Reader {
public:
  typedef IntList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasInts() const;
  inline  ::capnp::List< ::capnp_bench::Ints>::Reader getInts() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IntList::Builder {
public:
  typedef IntList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInts();
  inline  ::capnp::List< ::capnp_bench::Ints>::Builder getInts();
  inline void setInts( ::capnp::List< ::capnp_bench::Ints>::Reader value);
  inline  ::capnp::List< ::capnp_bench::Ints>::Builder initInts(unsigned int size);
  inline void adoptInts(::capnp::Orphan< ::capnp::List< ::capnp_bench::Ints>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::Ints>> disownInts();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IntList::Pipeline {
public:
  typedef IntList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mixed::Reader {
public:
  typedef Mixed Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline  ::int32_t getInt1() const;

  inline  ::int64_t getInt2() const;

  inline  ::uint32_t getUint1() const;

  inline double getFloat1() const;

  inline bool hasText1() const;
  inline  ::capnp::Text::Reader getText1() const;

  inline  ::capnp_bench::ENUMERATION getEnum1() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mixed::Builder {
public:
  typedef Mixed Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline  ::int32_t getInt1();
  inline void setInt1( ::int32_t value);

  inline  ::int64_t getInt2();
  inline void setInt2( ::int64_t value);

  inline  ::uint32_t getUint1();
  inline void setUint1( ::uint32_t value);

  inline double getFloat1();
  inline void setFloat1(double value);

  inline bool hasText1();
  inline  ::capnp::Text::Builder getText1();
  inline void setText1( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText1(unsigned int size);
  inline void adoptText1(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText1();

  inline  ::capnp_bench::ENUMERATION getEnum1();
  inline void setEnum1( ::capnp_bench::ENUMERATION value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mixed::Pipeline {
public:
  typedef Mixed Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MixedList::Reader {
public:
  typedef MixedList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMixed() const;
  inline  ::capnp::List< ::capnp_bench::Mixed>::Reader getMixed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MixedList::Builder {
public:
  typedef MixedList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMixed();
  inline  ::capnp::List< ::capnp_bench::Mixed>::Builder getMixed();
  inline void setMixed( ::capnp::List< ::capnp_bench::Mixed>::Reader value);
  inline  ::capnp::List< ::capnp_bench::Mixed>::Builder initMixed(unsigned int size);
  inline void adoptMixed(::capnp::Orphan< ::capnp::List< ::capnp_bench::Mixed>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::Mixed>> disownMixed();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MixedList::Pipeline {
public:
  typedef MixedList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ContainerVec::Reader {
public:
  typedef ContainerVec Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline  ::int64_t getInt1() const;

  inline bool hasText1() const;
  inline  ::capnp::Text::Reader getText1() const;

  inline bool hasStringvec() const;
  inline  ::capnp::List< ::capnp::Text>::Reader getStringvec() const;

  inline bool hasIntvec() const;
  inline  ::capnp::List< ::int64_t>::Reader getIntvec() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ContainerVec::Builder {
public:
  typedef ContainerVec Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline  ::int64_t getInt1();
  inline void setInt1( ::int64_t value);

  inline bool hasText1();
  inline  ::capnp::Text::Builder getText1();
  inline void setText1( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText1(unsigned int size);
  inline void adoptText1(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText1();

  inline bool hasStringvec();
  inline  ::capnp::List< ::capnp::Text>::Builder getStringvec();
  inline void setStringvec( ::capnp::List< ::capnp::Text>::Reader value);
  inline void setStringvec(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text>::Builder initStringvec(unsigned int size);
  inline void adoptStringvec(::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> disownStringvec();

  inline bool hasIntvec();
  inline  ::capnp::List< ::int64_t>::Builder getIntvec();
  inline void setIntvec( ::capnp::List< ::int64_t>::Reader value);
  inline void setIntvec(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t>::Builder initIntvec(unsigned int size);
  inline void adoptIntvec(::capnp::Orphan< ::capnp::List< ::int64_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t>> disownIntvec();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ContainerVec::Pipeline {
public:
  typedef ContainerVec Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ContainerVecList::Reader {
public:
  typedef ContainerVecList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasContvec() const;
  inline  ::capnp::List< ::capnp_bench::ContainerVec>::Reader getContvec() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ContainerVecList::Builder {
public:
  typedef ContainerVecList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContvec();
  inline  ::capnp::List< ::capnp_bench::ContainerVec>::Builder getContvec();
  inline void setContvec( ::capnp::List< ::capnp_bench::ContainerVec>::Reader value);
  inline  ::capnp::List< ::capnp_bench::ContainerVec>::Builder initContvec(unsigned int size);
  inline void adoptContvec(::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerVec>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerVec>> disownContvec();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ContainerVecList::Pipeline {
public:
  typedef ContainerVecList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Key, typename Value>
class Map<Key, Value>::Reader {
public:
  typedef Map Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasEntries() const;
  inline typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key, typename Value>
class Map<Key, Value>::Builder {
public:
  typedef Map Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEntries();
  inline typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Builder getEntries();
  inline void setEntries(typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Reader value);
  inline typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>&& value);
  inline ::capnp::Orphan< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key, typename Value>
class Map<Key, Value>::Pipeline {
public:
  typedef Map Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Key, typename Value>
class Map<Key, Value>::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::ReaderFor<Key> getKey() const;

  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<Value> getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key, typename Value>
class Map<Key, Value>::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::BuilderFor<Key> getKey();
  inline void setKey( ::capnp::ReaderFor<Key> value);
  inline  ::capnp::BuilderFor<Key> initKey();
  inline  ::capnp::BuilderFor<Key> initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan<Key>&& value);
  inline ::capnp::Orphan<Key> disownKey();

  inline bool hasValue();
  inline  ::capnp::BuilderFor<Value> getValue();
  inline void setValue( ::capnp::ReaderFor<Value> value);
  inline  ::capnp::BuilderFor<Value> initValue();
  inline  ::capnp::BuilderFor<Value> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<Value>&& value);
  inline ::capnp::Orphan<Value> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key, typename Value>
class Map<Key, Value>::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Key> getKey();
  inline  ::capnp::PipelineFor<Value> getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IntKey::Reader {
public:
  typedef IntKey Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IntKey::Builder {
public:
  typedef IntKey Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IntKey::Pipeline {
public:
  typedef IntKey Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StringMap::Reader {
public:
  typedef StringMap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasById() const;
  inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Reader getById() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StringMap::Builder {
public:
  typedef StringMap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasById();
  inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Builder getById();
  inline void setById( ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Reader value);
  inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Builder initById();
  inline void adoptById(::capnp::Orphan< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>> disownById();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StringMap::Pipeline {
public:
  typedef StringMap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Pipeline getById();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ContainerMap::Reader {
public:
  typedef ContainerMap Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline  ::int64_t getInt1() const;

  inline bool hasText1() const;
  inline  ::capnp::Text::Reader getText1() const;

  inline bool hasMap1() const;
  inline  ::capnp_bench::StringMap::Reader getMap1() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ContainerMap::Builder {
public:
  typedef ContainerMap Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline  ::int64_t getInt1();
  inline void setInt1( ::int64_t value);

  inline bool hasText1();
  inline  ::capnp::Text::Builder getText1();
  inline void setText1( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText1(unsigned int size);
  inline void adoptText1(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText1();

  inline bool hasMap1();
  inline  ::capnp_bench::StringMap::Builder getMap1();
  inline void setMap1( ::capnp_bench::StringMap::Reader value);
  inline  ::capnp_bench::StringMap::Builder initMap1();
  inline void adoptMap1(::capnp::Orphan< ::capnp_bench::StringMap>&& value);
  inline ::capnp::Orphan< ::capnp_bench::StringMap> disownMap1();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ContainerMap::Pipeline {
public:
  typedef ContainerMap Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp_bench::StringMap::Pipeline getMap1();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ContainerMapList::Reader {
public:
  typedef ContainerMapList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasContmap() const;
  inline  ::capnp::List< ::capnp_bench::ContainerMap>::Reader getContmap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ContainerMapList::Builder {
public:
  typedef ContainerMapList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContmap();
  inline  ::capnp::List< ::capnp_bench::ContainerMap>::Builder getContmap();
  inline void setContmap( ::capnp::List< ::capnp_bench::ContainerMap>::Reader value);
  inline  ::capnp::List< ::capnp_bench::ContainerMap>::Builder initContmap(unsigned int size);
  inline void adoptContmap(::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerMap>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerMap>> disownContmap();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ContainerMapList::Pipeline {
public:
  typedef ContainerMapList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Complex::Reader {
public:
  typedef Complex Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::int64_t getId() const;

  inline bool hasText1() const;
  inline  ::capnp::Text::Reader getText1() const;

  inline bool hasText2() const;
  inline  ::capnp::Text::Reader getText2() const;

  inline bool hasText3() const;
  inline  ::capnp::Text::Reader getText3() const;

  inline  ::int32_t getInt1() const;

  inline  ::int32_t getInt2() const;

  inline  ::int32_t getInt3() const;

  inline bool hasText4() const;
  inline  ::capnp::Text::Reader getText4() const;

  inline  ::capnp_bench::ENUMERATION getEnum1() const;

  inline double getFloat1() const;

  inline  ::int64_t getInt4() const;

  inline  ::uint32_t getUint1() const;

  inline  ::uint64_t getUint2() const;

  inline  ::int64_t getInt5() const;

  inline  ::int32_t getInt6() const;

  inline double getFloat2() const;

  inline bool hasText5() const;
  inline  ::capnp::Text::Reader getText5() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Complex::Builder {
public:
  typedef Complex Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int64_t getId();
  inline void setId( ::int64_t value);

  inline bool hasText1();
  inline  ::capnp::Text::Builder getText1();
  inline void setText1( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText1(unsigned int size);
  inline void adoptText1(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText1();

  inline bool hasText2();
  inline  ::capnp::Text::Builder getText2();
  inline void setText2( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText2(unsigned int size);
  inline void adoptText2(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText2();

  inline bool hasText3();
  inline  ::capnp::Text::Builder getText3();
  inline void setText3( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText3(unsigned int size);
  inline void adoptText3(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText3();

  inline  ::int32_t getInt1();
  inline void setInt1( ::int32_t value);

  inline  ::int32_t getInt2();
  inline void setInt2( ::int32_t value);

  inline  ::int32_t getInt3();
  inline void setInt3( ::int32_t value);

  inline bool hasText4();
  inline  ::capnp::Text::Builder getText4();
  inline void setText4( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText4(unsigned int size);
  inline void adoptText4(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText4();

  inline  ::capnp_bench::ENUMERATION getEnum1();
  inline void setEnum1( ::capnp_bench::ENUMERATION value);

  inline double getFloat1();
  inline void setFloat1(double value);

  inline  ::int64_t getInt4();
  inline void setInt4( ::int64_t value);

  inline  ::uint32_t getUint1();
  inline void setUint1( ::uint32_t value);

  inline  ::uint64_t getUint2();
  inline void setUint2( ::uint64_t value);

  inline  ::int64_t getInt5();
  inline void setInt5( ::int64_t value);

  inline  ::int32_t getInt6();
  inline void setInt6( ::int32_t value);

  inline double getFloat2();
  inline void setFloat2(double value);

  inline bool hasText5();
  inline  ::capnp::Text::Builder getText5();
  inline void setText5( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText5(unsigned int size);
  inline void adoptText5(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText5();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Complex::Pipeline {
public:
  typedef Complex Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ComplexList::Reader {
public:
  typedef ComplexList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasComplex() const;
  inline  ::capnp::List< ::capnp_bench::Complex>::Reader getComplex() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ComplexList::Builder {
public:
  typedef ComplexList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasComplex();
  inline  ::capnp::List< ::capnp_bench::Complex>::Builder getComplex();
  inline void setComplex( ::capnp::List< ::capnp_bench::Complex>::Reader value);
  inline  ::capnp::List< ::capnp_bench::Complex>::Builder initComplex(unsigned int size);
  inline void adoptComplex(::capnp::Orphan< ::capnp::List< ::capnp_bench::Complex>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::Complex>> disownComplex();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ComplexList::Pipeline {
public:
  typedef ComplexList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::int64_t Ints::Reader::getId() const {
  return _reader.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int64_t Ints::Builder::getId() {
  return _builder.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Ints::Builder::setId( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Ints::Reader::getInt1() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t Ints::Builder::getInt1() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Ints::Builder::setInt1( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Ints::Reader::getInt2() const {
  return _reader.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int64_t Ints::Builder::getInt2() {
  return _builder.getDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Ints::Builder::setInt2( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Ints::Reader::getInt3() const {
  return _reader.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::int32_t Ints::Builder::getInt3() {
  return _builder.getDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS);
}
inline void Ints::Builder::setInt3( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Ints::Reader::getInt4() const {
  return _reader.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int32_t Ints::Builder::getInt4() {
  return _builder.getDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS);
}
inline void Ints::Builder::setInt4( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline bool IntList::Reader::hasInts() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IntList::Builder::hasInts() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp_bench::Ints>::Reader IntList::Reader::getInts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Ints>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp_bench::Ints>::Builder IntList::Builder::getInts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Ints>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void IntList::Builder::setInts( ::capnp::List< ::capnp_bench::Ints>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Ints>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp_bench::Ints>::Builder IntList::Builder::initInts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Ints>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void IntList::Builder::adoptInts(
    ::capnp::Orphan< ::capnp::List< ::capnp_bench::Ints>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Ints>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::Ints>> IntList::Builder::disownInts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Ints>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int32_t Mixed::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t Mixed::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Mixed::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Mixed::Reader::getInt1() const {
  return _reader.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int32_t Mixed::Builder::getInt1() {
  return _builder.getDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Mixed::Builder::setInt1( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Mixed::Reader::getInt2() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t Mixed::Builder::getInt2() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void Mixed::Builder::setInt2( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Mixed::Reader::getUint1() const {
  return _reader.getDataField< ::uint32_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Mixed::Builder::getUint1() {
  return _builder.getDataField< ::uint32_t>(
      4 * ::capnp::ELEMENTS);
}
inline void Mixed::Builder::setUint1( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline double Mixed::Reader::getFloat1() const {
  return _reader.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}

inline double Mixed::Builder::getFloat1() {
  return _builder.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}
inline void Mixed::Builder::setFloat1(double value) {
  _builder.setDataField<double>(
      3 * ::capnp::ELEMENTS, value);
}

inline bool Mixed::Reader::hasText1() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Mixed::Builder::hasText1() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Mixed::Reader::getText1() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Mixed::Builder::getText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Mixed::Builder::setText1( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Mixed::Builder::initText1(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Mixed::Builder::adoptText1(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Mixed::Builder::disownText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::capnp_bench::ENUMERATION Mixed::Reader::getEnum1() const {
  return _reader.getDataField< ::capnp_bench::ENUMERATION>(
      10 * ::capnp::ELEMENTS);
}

inline  ::capnp_bench::ENUMERATION Mixed::Builder::getEnum1() {
  return _builder.getDataField< ::capnp_bench::ENUMERATION>(
      10 * ::capnp::ELEMENTS);
}
inline void Mixed::Builder::setEnum1( ::capnp_bench::ENUMERATION value) {
  _builder.setDataField< ::capnp_bench::ENUMERATION>(
      10 * ::capnp::ELEMENTS, value);
}

inline bool MixedList::Reader::hasMixed() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool MixedList::Builder::hasMixed() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp_bench::Mixed>::Reader MixedList::Reader::getMixed() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Mixed>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp_bench::Mixed>::Builder MixedList::Builder::getMixed() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Mixed>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void MixedList::Builder::setMixed( ::capnp::List< ::capnp_bench::Mixed>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Mixed>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp_bench::Mixed>::Builder MixedList::Builder::initMixed(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Mixed>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void MixedList::Builder::adoptMixed(
    ::capnp::Orphan< ::capnp::List< ::capnp_bench::Mixed>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Mixed>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::Mixed>> MixedList::Builder::disownMixed() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Mixed>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int32_t ContainerVec::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t ContainerVec::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void ContainerVec::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t ContainerVec::Reader::getInt1() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t ContainerVec::Builder::getInt1() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void ContainerVec::Builder::setInt1( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool ContainerVec::Reader::hasText1() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool ContainerVec::Builder::hasText1() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ContainerVec::Reader::getText1() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ContainerVec::Builder::getText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void ContainerVec::Builder::setText1( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ContainerVec::Builder::initText1(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void ContainerVec::Builder::adoptText1(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ContainerVec::Builder::disownText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool ContainerVec::Reader::hasStringvec() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool ContainerVec::Builder::hasStringvec() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text>::Reader ContainerVec::Reader::getStringvec() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text>::Builder ContainerVec::Builder::getStringvec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void ContainerVec::Builder::setStringvec( ::capnp::List< ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline void ContainerVec::Builder::setStringvec(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text>::Builder ContainerVec::Builder::initStringvec(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void ContainerVec::Builder::adoptStringvec(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text>> ContainerVec::Builder::disownStringvec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text>>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool ContainerVec::Reader::hasIntvec() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool ContainerVec::Builder::hasIntvec() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t>::Reader ContainerVec::Reader::getIntvec() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int64_t>::Builder ContainerVec::Builder::getIntvec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void ContainerVec::Builder::setIntvec( ::capnp::List< ::int64_t>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline void ContainerVec::Builder::setIntvec(::kj::ArrayPtr<const  ::int64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t>::Builder ContainerVec::Builder::initIntvec(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void ContainerVec::Builder::adoptIntvec(
    ::capnp::Orphan< ::capnp::List< ::int64_t>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t>> ContainerVec::Builder::disownIntvec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t>>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline bool ContainerVecList::Reader::hasContvec() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool ContainerVecList::Builder::hasContvec() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp_bench::ContainerVec>::Reader ContainerVecList::Reader::getContvec() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerVec>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp_bench::ContainerVec>::Builder ContainerVecList::Builder::getContvec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerVec>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void ContainerVecList::Builder::setContvec( ::capnp::List< ::capnp_bench::ContainerVec>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerVec>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp_bench::ContainerVec>::Builder ContainerVecList::Builder::initContvec(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerVec>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void ContainerVecList::Builder::adoptContvec(
    ::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerVec>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerVec>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerVec>> ContainerVecList::Builder::disownContvec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerVec>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Reader::hasEntries() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Builder::hasEntries() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Reader Map<Key, Value>::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Builder Map<Key, Value>::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Builder::setEntries(typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>::Builder Map<Key, Value>::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>> Map<Key, Value>::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::capnp_bench::Map<Key, Value>::Entry>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Reader::hasKey() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Builder::hasKey() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Key> Map<Key, Value>::Entry::Reader::getKey() const {
  return ::capnp::_::PointerHelpers<Key>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::getKey() {
  return ::capnp::_::PointerHelpers<Key>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Key> Map<Key, Value>::Entry::Pipeline::getKey() {
  return  ::capnp::PipelineFor<Key>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::setKey( ::capnp::ReaderFor<Key> value) {
  ::capnp::_::PointerHelpers<Key>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::initKey() {
  return ::capnp::_::PointerHelpers<Key>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers<Key>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::adoptKey(
    ::capnp::Orphan<Key>&& value) {
  ::capnp::_::PointerHelpers<Key>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Key> Map<Key, Value>::Entry::Builder::disownKey() {
  return ::capnp::_::PointerHelpers<Key>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Reader::hasValue() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Builder::hasValue() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Value> Map<Key, Value>::Entry::Reader::getValue() const {
  return ::capnp::_::PointerHelpers<Value>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::getValue() {
  return ::capnp::_::PointerHelpers<Value>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Value> Map<Key, Value>::Entry::Pipeline::getValue() {
  return  ::capnp::PipelineFor<Value>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::setValue( ::capnp::ReaderFor<Value> value) {
  ::capnp::_::PointerHelpers<Value>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::initValue() {
  return ::capnp::_::PointerHelpers<Value>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers<Value>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::adoptValue(
    ::capnp::Orphan<Value>&& value) {
  ::capnp::_::PointerHelpers<Value>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Value> Map<Key, Value>::Entry::Builder::disownValue() {
  return ::capnp::_::PointerHelpers<Value>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

// Map<Key, Value>::Entry
#ifndef _MSC_VER
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::Entry::_capnpPrivate::dataWordSize;
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::Entry::_capnpPrivate::pointerCount;
#endif
#if !CAPNP_LITE
template <typename Key, typename Value>
constexpr ::capnp::Kind Map<Key, Value>::Entry::_capnpPrivate::kind;
template <typename Key, typename Value>
constexpr ::capnp::_::RawSchema const* Map<Key, Value>::Entry::_capnpPrivate::schema;
template <typename Key, typename Value>
constexpr ::capnp::_::RawBrandedSchema const* Map<Key, Value>::Entry::_capnpPrivate::brand;
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Scope Map<Key, Value>::Entry::_capnpPrivate::brandScopes[] = {
  { 0xf1acf663667b09ab, brandBindings + 0, 2, false},
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Binding Map<Key, Value>::Entry::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema Map<Key, Value>::Entry::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_860ba9e9f415fbc6, brandScopes, nullptr,
  sizeof(brandScopes) / sizeof(brandScopes[0]), 0, nullptr
};
#endif  // !CAPNP_LITE

// Map<Key, Value>
#ifndef _MSC_VER
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::_capnpPrivate::dataWordSize;
template <typename Key, typename Value>
constexpr uint16_t Map<Key, Value>::_capnpPrivate::pointerCount;
#endif
#if !CAPNP_LITE
template <typename Key, typename Value>
constexpr ::capnp::Kind Map<Key, Value>::_capnpPrivate::kind;
template <typename Key, typename Value>
constexpr ::capnp::_::RawSchema const* Map<Key, Value>::_capnpPrivate::schema;
template <typename Key, typename Value>
constexpr ::capnp::_::RawBrandedSchema const* Map<Key, Value>::_capnpPrivate::brand;
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Scope Map<Key, Value>::_capnpPrivate::brandScopes[] = {
  { 0xf1acf663667b09ab, brandBindings + 0, 2, false},
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Binding Map<Key, Value>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Dependency Map<Key, Value>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::capnp_bench::Map<Key, Value>::Entry::_capnpPrivate::brand },
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema Map<Key, Value>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_f1acf663667b09ab, brandScopes, brandDependencies,
  sizeof(brandScopes) / sizeof(brandScopes[0]), sizeof(brandDependencies) / sizeof(brandDependencies[0]), nullptr
};
#endif  // !CAPNP_LITE

inline  ::int32_t IntKey::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t IntKey::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void IntKey::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool StringMap::Reader::hasById() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool StringMap::Builder::hasById() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Reader StringMap::Reader::getById() const {
  return ::capnp::_::PointerHelpers< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Builder StringMap::Builder::getById() {
  return ::capnp::_::PointerHelpers< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Pipeline StringMap::Pipeline::getById() {
  return  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void StringMap::Builder::setById( ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>::Builder StringMap::Builder::initById() {
  return ::capnp::_::PointerHelpers< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void StringMap::Builder::adoptById(
    ::capnp::Orphan< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>> StringMap::Builder::disownById() {
  return ::capnp::_::PointerHelpers< ::capnp_bench::Map< ::capnp_bench::IntKey,  ::capnp::Text>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int32_t ContainerMap::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int32_t ContainerMap::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS);
}
inline void ContainerMap::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t ContainerMap::Reader::getInt1() const {
  return _reader.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::int64_t ContainerMap::Builder::getInt1() {
  return _builder.getDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void ContainerMap::Builder::setInt1( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      1 * ::capnp::ELEMENTS, value);
}

inline bool ContainerMap::Reader::hasText1() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool ContainerMap::Builder::hasText1() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ContainerMap::Reader::getText1() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ContainerMap::Builder::getText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void ContainerMap::Builder::setText1( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ContainerMap::Builder::initText1(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void ContainerMap::Builder::adoptText1(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ContainerMap::Builder::disownText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool ContainerMap::Reader::hasMap1() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool ContainerMap::Builder::hasMap1() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp_bench::StringMap::Reader ContainerMap::Reader::getMap1() const {
  return ::capnp::_::PointerHelpers< ::capnp_bench::StringMap>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp_bench::StringMap::Builder ContainerMap::Builder::getMap1() {
  return ::capnp::_::PointerHelpers< ::capnp_bench::StringMap>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp_bench::StringMap::Pipeline ContainerMap::Pipeline::getMap1() {
  return  ::capnp_bench::StringMap::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ContainerMap::Builder::setMap1( ::capnp_bench::StringMap::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp_bench::StringMap>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp_bench::StringMap::Builder ContainerMap::Builder::initMap1() {
  return ::capnp::_::PointerHelpers< ::capnp_bench::StringMap>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void ContainerMap::Builder::adoptMap1(
    ::capnp::Orphan< ::capnp_bench::StringMap>&& value) {
  ::capnp::_::PointerHelpers< ::capnp_bench::StringMap>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp_bench::StringMap> ContainerMap::Builder::disownMap1() {
  return ::capnp::_::PointerHelpers< ::capnp_bench::StringMap>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool ContainerMapList::Reader::hasContmap() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool ContainerMapList::Builder::hasContmap() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp_bench::ContainerMap>::Reader ContainerMapList::Reader::getContmap() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerMap>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp_bench::ContainerMap>::Builder ContainerMapList::Builder::getContmap() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerMap>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void ContainerMapList::Builder::setContmap( ::capnp::List< ::capnp_bench::ContainerMap>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerMap>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp_bench::ContainerMap>::Builder ContainerMapList::Builder::initContmap(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerMap>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void ContainerMapList::Builder::adoptContmap(
    ::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerMap>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerMap>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::ContainerMap>> ContainerMapList::Builder::disownContmap() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::ContainerMap>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline  ::int64_t Complex::Reader::getId() const {
  return _reader.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::int64_t Complex::Builder::getId() {
  return _builder.getDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setId( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool Complex::Reader::hasText1() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool Complex::Builder::hasText1() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Complex::Reader::getText1() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Complex::Builder::getText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void Complex::Builder::setText1( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Complex::Builder::initText1(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void Complex::Builder::adoptText1(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Complex::Builder::disownText1() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool Complex::Reader::hasText2() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool Complex::Builder::hasText2() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Complex::Reader::getText2() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Complex::Builder::getText2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline void Complex::Builder::setText2( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Complex::Builder::initText2(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(1 * ::capnp::POINTERS), size);
}
inline void Complex::Builder::adoptText2(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Complex::Builder::disownText2() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}

inline bool Complex::Reader::hasText3() const {
  return !_reader.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline bool Complex::Builder::hasText3() {
  return !_builder.getPointerField(2 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Complex::Reader::getText3() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(2 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Complex::Builder::getText3() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}
inline void Complex::Builder::setText3( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(2 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Complex::Builder::initText3(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(2 * ::capnp::POINTERS), size);
}
inline void Complex::Builder::adoptText3(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(2 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Complex::Builder::disownText3() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(2 * ::capnp::POINTERS));
}

inline  ::int32_t Complex::Reader::getInt1() const {
  return _reader.getDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS);
}

inline  ::int32_t Complex::Builder::getInt1() {
  return _builder.getDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setInt1( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      2 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Complex::Reader::getInt2() const {
  return _reader.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}

inline  ::int32_t Complex::Builder::getInt2() {
  return _builder.getDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setInt2( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Complex::Reader::getInt3() const {
  return _reader.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::int32_t Complex::Builder::getInt3() {
  return _builder.getDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setInt3( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline bool Complex::Reader::hasText4() const {
  return !_reader.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline bool Complex::Builder::hasText4() {
  return !_builder.getPointerField(3 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Complex::Reader::getText4() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(3 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Complex::Builder::getText4() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}
inline void Complex::Builder::setText4( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(3 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Complex::Builder::initText4(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(3 * ::capnp::POINTERS), size);
}
inline void Complex::Builder::adoptText4(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(3 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Complex::Builder::disownText4() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(3 * ::capnp::POINTERS));
}

inline  ::capnp_bench::ENUMERATION Complex::Reader::getEnum1() const {
  return _reader.getDataField< ::capnp_bench::ENUMERATION>(
      10 * ::capnp::ELEMENTS);
}

inline  ::capnp_bench::ENUMERATION Complex::Builder::getEnum1() {
  return _builder.getDataField< ::capnp_bench::ENUMERATION>(
      10 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setEnum1( ::capnp_bench::ENUMERATION value) {
  _builder.setDataField< ::capnp_bench::ENUMERATION>(
      10 * ::capnp::ELEMENTS, value);
}

inline double Complex::Reader::getFloat1() const {
  return _reader.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}

inline double Complex::Builder::getFloat1() {
  return _builder.getDataField<double>(
      3 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setFloat1(double value) {
  _builder.setDataField<double>(
      3 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Complex::Reader::getInt4() const {
  return _reader.getDataField< ::int64_t>(
      4 * ::capnp::ELEMENTS);
}

inline  ::int64_t Complex::Builder::getInt4() {
  return _builder.getDataField< ::int64_t>(
      4 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setInt4( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      4 * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Complex::Reader::getUint1() const {
  return _reader.getDataField< ::uint32_t>(
      10 * ::capnp::ELEMENTS);
}

inline  ::uint32_t Complex::Builder::getUint1() {
  return _builder.getDataField< ::uint32_t>(
      10 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setUint1( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      10 * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Complex::Reader::getUint2() const {
  return _reader.getDataField< ::uint64_t>(
      6 * ::capnp::ELEMENTS);
}

inline  ::uint64_t Complex::Builder::getUint2() {
  return _builder.getDataField< ::uint64_t>(
      6 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setUint2( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      6 * ::capnp::ELEMENTS, value);
}

inline  ::int64_t Complex::Reader::getInt5() const {
  return _reader.getDataField< ::int64_t>(
      7 * ::capnp::ELEMENTS);
}

inline  ::int64_t Complex::Builder::getInt5() {
  return _builder.getDataField< ::int64_t>(
      7 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setInt5( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      7 * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Complex::Reader::getInt6() const {
  return _reader.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}

inline  ::int32_t Complex::Builder::getInt6() {
  return _builder.getDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setInt6( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      11 * ::capnp::ELEMENTS, value);
}

inline double Complex::Reader::getFloat2() const {
  return _reader.getDataField<double>(
      8 * ::capnp::ELEMENTS);
}

inline double Complex::Builder::getFloat2() {
  return _builder.getDataField<double>(
      8 * ::capnp::ELEMENTS);
}
inline void Complex::Builder::setFloat2(double value) {
  _builder.setDataField<double>(
      8 * ::capnp::ELEMENTS, value);
}

inline bool Complex::Reader::hasText5() const {
  return !_reader.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline bool Complex::Builder::hasText5() {
  return !_builder.getPointerField(4 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Complex::Reader::getText5() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(4 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Complex::Builder::getText5() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}
inline void Complex::Builder::setText5( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(4 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Complex::Builder::initText5(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(4 * ::capnp::POINTERS), size);
}
inline void Complex::Builder::adoptText5(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(4 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Complex::Builder::disownText5() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(4 * ::capnp::POINTERS));
}

inline bool ComplexList::Reader::hasComplex() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool ComplexList::Builder::hasComplex() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp_bench::Complex>::Reader ComplexList::Reader::getComplex() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Complex>>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp_bench::Complex>::Builder ComplexList::Builder::getComplex() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Complex>>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void ComplexList::Builder::setComplex( ::capnp::List< ::capnp_bench::Complex>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Complex>>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp_bench::Complex>::Builder ComplexList::Builder::initComplex(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Complex>>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void ComplexList::Builder::adoptComplex(
    ::capnp::Orphan< ::capnp::List< ::capnp_bench::Complex>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Complex>>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp_bench::Complex>> ComplexList::Builder::disownComplex() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp_bench::Complex>>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

}  // namespace

#endif  // CAPNP_INCLUDED_c95f38542f78fdf9_
